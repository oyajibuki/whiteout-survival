<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>‚ùÑÔ∏è „Éõ„ÉØ„Ç§„Éà„Ç¢„Ç¶„Éà„Éª„Çµ„Éê„Ç§„Éê„É´</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #0a1628;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      touch-action: none;
      user-select: none;
      font-family: 'Helvetica Neue', Arial, sans-serif;
    }

    #c {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px 10px 4px;
      background: linear-gradient(rgba(0, 0, 0, .65), transparent);
      display: flex;
      gap: 7px;
      align-items: center;
      flex-wrap: wrap;
      pointer-events: none;
      z-index: 10;
    }

    .hres {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(0, 0, 0, .55);
      border: 1px solid rgba(255, 255, 255, .12);
      border-radius: 15px;
      padding: 4px 10px;
      color: white;
      font-size: 13px;
      font-weight: 700;
    }

    #day-badge {
      margin-left: auto;
      background: rgba(0, 0, 0, .55);
      border: 1px solid rgba(255, 215, 0, .3);
      border-radius: 15px;
      padding: 4px 10px;
      color: #f1c40f;
      font-size: 12px;
      font-weight: 700;
    }

    #hp-row {
      position: fixed;
      top: 46px;
      left: 10px;
      right: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      pointer-events: none;
      z-index: 10;
    }

    #hp-bg {
      flex: 1;
      height: 10px;
      background: rgba(0, 0, 0, .5);
      border-radius: 5px;
      overflow: hidden;
      border: 1px solid rgba(255, 60, 60, .3);
    }

    #hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #e74c3c, #ff6b6b);
      border-radius: 5px;
      transition: width .15s;
    }

    #hp-label {
      color: white;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
    }

    #toast {
      position: fixed;
      top: 72px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, .88);
      color: white;
      padding: 7px 18px;
      border-radius: 18px;
      font-size: 13px;
      font-weight: 700;
      z-index: 30;
      opacity: 0;
      transition: opacity .3s;
      pointer-events: none;
      white-space: nowrap;
      max-width: 92vw;
      text-align: center;
    }

    #toast.show {
      opacity: 1;
    }

    #hint {
      position: fixed;
      bottom: 178px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, .78);
      color: white;
      font-size: 12px;
      font-weight: 700;
      padding: 6px 16px;
      border-radius: 14px;
      z-index: 10;
      pointer-events: none;
      opacity: 0;
      transition: opacity .3s;
      white-space: nowrap;
    }

    #hint.show {
      opacity: 1;
    }

    #chop-wrap {
      position: fixed;
      bottom: 205px;
      left: 50%;
      transform: translateX(-50%);
      width: 190px;
      display: none;
      z-index: 10;
    }

    #chop-lbl {
      color: #aef;
      text-align: center;
      font-size: 11px;
      font-weight: 700;
      text-shadow: 1px 1px 2px black;
      margin-bottom: 3px;
    }

    #chop-bg {
      height: 9px;
      background: rgba(0, 0, 0, .55);
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 5px;
      overflow: hidden;
    }

    #chop-bar {
      height: 100%;
      background: linear-gradient(90deg, #27ae60, #2ecc71);
      border-radius: 5px;
      width: 0%;
    }

    #shop {
      position: fixed;
      inset: 0;
      background: rgba(5, 12, 25, .96);
      z-index: 50;
      display: none;
      flex-direction: column;
      overflow-y: auto;
    }

    #shop.open {
      display: flex;
    }

    #shop-top {
      padding: 16px 14px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(255, 255, 255, .08);
      background: linear-gradient(135deg, #0d2137, #0a1628);
      flex-shrink: 0;
      gap: 10px;
    }

    #shop-top h2 {
      color: #f1c40f;
      font-size: 20px;
      margin: 0;
    }

    #shop-res {
      color: white;
      font-size: 12px;
      background: rgba(255, 255, 255, .08);
      padding: 4px 10px;
      border-radius: 12px;
      white-space: nowrap;
    }

    #shop-x {
      color: white;
      font-size: 26px;
      cursor: pointer;
      padding: 2px 8px;
    }

    #shop-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      padding: 12px;
    }

    .si {
      background: linear-gradient(145deg, #112240, #0a1628);
      border: 1.5px solid rgba(255, 255, 255, .1);
      border-radius: 14px;
      padding: 13px 8px;
      text-align: center;
      cursor: pointer;
      transition: all .13s;
      color: white;
    }

    .si:active {
      transform: scale(0.94);
    }

    .si.ok {
      border-color: #27ae60;
      background: linear-gradient(145deg, #0d2b1e, #091a12);
    }

    .si .sico {
      font-size: 32px;
      display: block;
      margin-bottom: 4px;
    }

    .si .snm {
      font-size: 13px;
      font-weight: 700;
      margin-bottom: 2px;
    }

    .si .sds {
      font-size: 10px;
      color: #7f8c8d;
      margin-bottom: 6px;
      min-height: 28px;
    }

    .si .sct {
      font-size: 12px;
      font-weight: 700;
      display: inline-block;
      background: rgba(0, 0, 0, .35);
      border-radius: 10px;
      padding: 3px 10px;
    }

    .si.ok .sct {
      color: #2ecc71;
    }

    .si:not(.ok) .sct {
      color: #7f8c8d;
    }

    .si .slv {
      font-size: 10px;
      color: #f1c40f;
      margin-top: 3px;
    }

    .flt {
      position: fixed;
      font-size: 17px;
      font-weight: 900;
      pointer-events: none;
      z-index: 25;
      animation: fltup 1.1s ease-out forwards;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, .9);
    }

    @keyframes fltup {
      0% {
        opacity: 1;
        transform: translateY(0) scale(1)
      }

      100% {
        opacity: 0;
        transform: translateY(-70px) scale(1.25)
      }
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <div id="hud">
    <div class="hres">üí∞ <span id="h-money">50</span></div>
    <div class="hres">ü•© <span id="h-meat">0</span></div>
    <div class="hres">ü™µ <span id="h-wood">0</span></div>
    <div id="day-badge">Day <span id="h-day">1</span></div>
  </div>
  <div id="hp-row">
    <span id="hp-label">‚ù§Ô∏è <span id="hp-num">100</span>/<span id="hp-max">100</span></span>
    <div id="hp-bg">
      <div id="hp-fill"></div>
    </div>
  </div>
  <div id="hint"></div>
  <div id="chop-wrap">
    <div id="chop-lbl">ü™ì ‰ºêÊé°‰∏≠...</div>
    <div id="chop-bg">
      <div id="chop-bar"></div>
    </div>
  </div>
  <div id="toast"></div>
  <div id="shop">
    <div id="shop-top">
      <h2>üè™ „Ç∑„Éß„ÉÉ„Éó</h2>
      <div id="shop-res"></div>
      <span id="shop-x" onclick="closeShop()">‚úï</span>
    </div>
    <div id="shop-grid"></div>
  </div>
  <script>
    // ===== CONFIG =====
    const TW = 60, TH = 30, MAP = 64, CX = 32, CY = 32;
    const PSPD = 4.5, JRAD = 55, BSIGHT = 5, BSPD = 1.6, BATKR = 1.7, TREERANGE = 2.0, CHOPBASE = 1800;

    // ===== CANVAS =====
    const cv = document.getElementById('c'), ctx = cv.getContext('2d');
    let W = 0, H = 0;
    function resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      W = window.innerWidth; H = window.innerHeight;
      cv.width = W * dpr; cv.height = H * dpr;
      cv.style.width = W + 'px'; cv.style.height = H + 'px';
      ctx.scale(dpr, dpr);
    }
    resize(); window.addEventListener('resize', resize);

    // ===== ISO =====
    function iso(wx, wy) { return { sx: (wx - wy) * TW / 2, sy: (wx + wy) * TH / 2 }; }
    function w2s(wx, wy) { const c = iso(g.cx, g.cy), p = iso(wx, wy); return { x: p.sx - c.sx + W / 2, y: p.sy - c.sy + H / 2 }; }

    // ===== GAME STATE =====
    const g = {
      money: 50, meat: 0, wood: 0, time: 0,
      cx: CX + .5, cy: CY + .5,
      terR: 6, sellRate: 6,
      p: { x: CX + .5, y: CY + .5, angle: 0, hp: 100, maxHp: 100, swordLv: 1, axeLv: 1, armorLv: 1, wCnt: 0, atkCD: 0, hurtCD: 0, atkAnim: 0 },
      trees: [], bears: [], workers: [], particles: [], walls: [],
      swordAngle: 0,
      joyActive: false, joyId: null, joyOX: 80, joyOY: 600, joyDX: 0, joyDY: 0,
      actDown: false, actId: null,
      chopProg: 0, chopActive: false,
      repairProg: 0, repairActive: false,
      nearBase: false, nearTree: null, nearBear: null, nearWall: null
    };

    // ===== TILE MAP =====
    let tiles = [], tShade = [];
    function genMap() {
      tiles = []; tShade = [];
      for (let y = 0; y < MAP; y++) {
        tiles[y] = []; tShade[y] = [];
        for (let x = 0; x < MAP; x++) {
          const d = Math.hypot(x - CX, y - CY);
          // type 0: inside territory (white path)
          // type 1: known wide area (safe snow)
          // type 2: near base (dirt/camp)
          // type 3: unknown dark area (fog)
          tiles[y][x] = d < g.terR + 1 ? (d < 3.5 ? 2 : 0) : (d < g.terR + 8 ? 1 : 3);
          tShade[y][x] = Math.random() * .08 - .04;
        }
      }
      genWalls();
    }

    function genWalls() {
      g.walls = [];
      const r = g.terR;
      const wallHp = 50 + (r * 10);
      for (let y = 0; y < MAP; y++) {
        for (let x = 0; x < MAP; x++) {
          const d = Math.hypot(x - CX, y - CY);
          // Only place walls at the exact boundary radius
          if (d >= r && d < r + 1.2) {
            // Leave a gate at the South (y > CY and x is near CX)
            if (y > CY && Math.abs(x - CX) <= 1) continue;

            // Check spacing so we don't have overlapping walls
            if (!g.walls.some(w => Math.hypot(w.x - x, w.y - y) < 0.8)) {
              g.walls.push({ x: x + .5, y: y + .5, hp: wallHp, maxHp: wallHp, dead: false });
            }
          }
        }
      }
    }

    // ===== ENTITIES =====
    function mkTree(x, y) {
      const dist = Math.hypot(x - CX, y - CY);
      const scale = 1 + Math.max(0, (dist - 10) * 0.05); // Grows up to ~3x
      const hpBase = Math.floor(3 * scale);
      return { x, y, hp: hpBase, maxHp: hpBase, scale: scale, dropMult: scale, dead: false, respawn: 0, wobble: 0 };
    }
    function mkBear(x, y) {
      // Map expansion scaling: Bear stats scale with distance from center
      const dist = Math.hypot(x - CX, y - CY);
      const hpMult = 1 + Math.max(0, (dist - 6) * 0.15); // +15% HP per tile beyond safe zone
      const sizeMult = 1 + Math.max(0, (dist - 10) * 0.04);
      const bearHp = (60 + Math.random() * 40) * hpMult;
      return { x, y, spawnX: x, spawnY: y, hp: bearHp, maxHp: 0, dmgMult: hpMult, scale: sizeMult, dropMult: sizeMult, dead: false, respawn: 0, angle: Math.random() * Math.PI * 2, state: 'patrol', atkCD: 0, hurtFlash: 0, wanderT: Math.random() * 3000, init: 1 };
    }
    function mkWorker() { return { x: CX + (Math.random() - .5) * 2, y: CY + (Math.random() - .5) * 2, angle: 0, state: 'idle', target: null, wood: 0, meat: 0, atkCD: 0, chopT: 0 }; }

    function spawnEntities() {
      g.trees = []; g.bears = [];
      let att = 0;
      while (g.trees.length < 160 && att < 3000) { att++; const a = Math.random() * Math.PI * 2, d = 4.5 + Math.random() * 30, x = CX + Math.cos(a) * d, y = CY + Math.sin(a) * d; if (x < 1 || x > MAP - 1 || y < 1 || y > MAP - 1) continue; if (g.trees.some(t => Math.hypot(t.x - x, t.y - y) < 1.5)) continue; g.trees.push(mkTree(x, y)); }
      att = 0;
      while (g.bears.length < 40 && att < 2000) { att++; const a = Math.random() * Math.PI * 2, d = 7 + Math.random() * 28, x = CX + Math.cos(a) * d, y = CY + Math.sin(a) * d; if (x < 1 || x > MAP - 1 || y < 1 || y > MAP - 1) continue; const b = mkBear(x, y); b.maxHp = b.hp; g.bears.push(b); }
    }

    // ===== SHOP DATA =====
    const SHOP = [
      {
        id: 'sword', ico: '‚öîÔ∏è', name: 'Ââ£„ÇíÂº∑Âåñ', desc: 'ÊîªÊíÉÂäõ„Ç¢„ÉÉ„Éó', maxLv: 4, baseLv: 1, getLv: () => g.p.swordLv,
        lvls: [{ cost: { money: 100 }, lbl: 'Lv2 ÊîªÊíÉ+15', fn: () => { g.p.swordLv = 2; } }, { cost: { money: 250 }, lbl: 'Lv3 ÊîªÊíÉ+30', fn: () => { g.p.swordLv = 3; } }, { cost: { money: 500 }, lbl: 'Lv4 ÊîªÊíÉMAX', fn: () => { g.p.swordLv = 4; } }]
      },
      {
        id: 'axe', ico: 'ü™ì', name: 'Êñß„ÇíÂº∑Âåñ', desc: '‰ºêÊé°ÈÄüÂ∫¶„Ç¢„ÉÉ„Éó', maxLv: 4, baseLv: 1, getLv: () => g.p.axeLv,
        lvls: [{ cost: { wood: 15 }, lbl: 'Lv2 2ÂÄçÈÄü', fn: () => { g.p.axeLv = 2; } }, { cost: { wood: 35 }, lbl: 'Lv3 3ÂÄçÈÄü', fn: () => { g.p.axeLv = 3; } }, { cost: { wood: 70 }, lbl: 'Lv4 4ÂÄçÈÄü', fn: () => { g.p.axeLv = 4; } }]
      },
      {
        id: 'armor', ico: 'üõ°Ô∏è', name: 'Èéß„ÇíÂº∑Âåñ', desc: 'HP„ÉªÈò≤Âæ°Âäõ„Ç¢„ÉÉ„Éó', maxLv: 4, baseLv: 1, getLv: () => g.p.armorLv,
        lvls: [{ cost: { money: 150, wood: 10 }, lbl: 'Lv2 HP+50', fn: () => { g.p.armorLv = 2; g.p.maxHp = 150; g.p.hp = Math.min(g.p.hp + 50, 150); } }, { cost: { money: 350, wood: 25 }, lbl: 'Lv3 HP+100', fn: () => { g.p.armorLv = 3; g.p.maxHp = 200; g.p.hp = Math.min(g.p.hp + 50, 200); } }, { cost: { money: 700, wood: 50 }, lbl: 'Lv4 HP MAX', fn: () => { g.p.armorLv = 4; g.p.maxHp = 250; g.p.hp = Math.min(g.p.hp + 50, 250); } }]
      },
      {
        id: 'worker', ico: 'üë∑', name: '‰ª≤Èñì„ÇíÈõá„ÅÜ', desc: 'Ëá™Âãï„Åß‰ºêÊé°„ÉªÁã©„Çä„Çí„Åô„Çã', maxLv: 3, getLv: () => g.p.wCnt,
        lvls: [{ cost: { money: 200 }, lbl: '1‰∫∫ÁõÆ', fn: () => { g.workers.push(mkWorker()); g.p.wCnt = 1; } }, { cost: { money: 400 }, lbl: '2‰∫∫ÁõÆ', fn: () => { g.workers.push(mkWorker()); g.p.wCnt = 2; } }, { cost: { money: 700 }, lbl: '3‰∫∫ÁõÆ', fn: () => { g.workers.push(mkWorker()); g.p.wCnt = 3; } }]
      },
      {
        id: 'territory', ico: 'üè∞', name: 'È†òÂúü„ÇíÂ∫É„Åí„Çã', desc: 'Êé¢Á¥¢„Åß„Åç„Çã„Ç®„É™„Ç¢Êã°Â§ß', maxLv: 4,
        getLv: () => g.terR >= 24 ? 4 : g.terR >= 18 ? 3 : g.terR >= 12 ? 2 : g.terR >= 8 ? 1 : 0,
        lvls: [{ cost: { money: 300, wood: 25 }, lbl: 'ÂçäÂæÑ8', fn: () => { g.terR = 8; genMap(); } }, { cost: { money: 600, wood: 55 }, lbl: 'ÂçäÂæÑ12', fn: () => { g.terR = 12; genMap(); } }, { cost: { money: 1200, wood: 100 }, lbl: 'ÂçäÂæÑ18', fn: () => { g.terR = 18; genMap(); } }, { cost: { money: 2500, wood: 200 }, lbl: 'ÂÖ®ÂüüËß£ÊîæÔºÅ', fn: () => { g.terR = 24; genMap(); toast('‚ú® ÂÖ®È†òÂúü„ÇíËß£Êîæ„Åó„ÅüÔºÅ„Åì„ÅÆ„Åæ„Åæ„Ç®„É≥„Éâ„É¨„Çπ„ÅßÈÅä„Åπ„Åæ„ÅôÔºÅ'); } }]
      },
      {
        id: 'market', ico: 'üì¶', name: 'ËÇâ„ÅÆÂ£≤ÂÄ§UP', desc: '„ÅäËÇâ„Çí„Çà„ÇäÈ´ò„ÅèÂ£≤„Çå„Çã', maxLv: 3,
        getLv: () => g.sellRate >= 18 ? 3 : g.sellRate >= 12 ? 2 : g.sellRate >= 8 ? 1 : 0,
        lvls: [{ cost: { money: 200 }, lbl: '1ÂÄã‚Üí8ÂÜÜ', fn: () => { g.sellRate = 8; } }, { cost: { money: 450 }, lbl: '1ÂÄã‚Üí12ÂÜÜ', fn: () => { g.sellRate = 12; } }, { cost: { money: 900 }, lbl: '1ÂÄã‚Üí18ÂÜÜ', fn: () => { g.sellRate = 18; } }]
      },
    ];

    function canAfford(c) { return !(c.money && g.money < c.money) && !(c.wood && g.wood < c.wood); }
    function buyItem(item) {
      const lv = item.getLv(); if (lv >= item.maxLv) return;
      const ld = item.lvls[lv - (item.baseLv || 0)]; if (!canAfford(ld.cost)) { toast('üí∏ „É™„ÇΩ„Éº„Çπ„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºÅ'); return; }
      if (ld.cost.money) g.money -= ld.cost.money; if (ld.cost.wood) g.wood -= ld.cost.wood;
      ld.fn(); toast('‚úÖ ' + item.name + ' „Ç¢„ÉÉ„Éó„Ç∞„É¨„Éº„ÉâÔºÅ'); buildShopUI();
    }
    function buildShopUI() {
      document.getElementById('shop-res').textContent = 'üí∞' + Math.floor(g.money) + ' ü™µ' + g.wood;
      const grid = document.getElementById('shop-grid'); grid.innerHTML = '';
      SHOP.forEach(item => {
        const lv = item.getLv(), maxed = lv >= item.maxLv, ld = maxed ? null : item.lvls[lv - (item.baseLv || 0)], afford = ld && canAfford(ld.cost);
        const d = document.createElement('div'); d.className = 'si' + (afford ? ' ok' : '');
        let cs = maxed ? '<span class="sct" style="color:#f1c40f">‚úÖ MAX</span>' :
          '<span class="sct">' + (ld.cost.money ? 'üí∞' + ld.cost.money : '') + (ld.cost.wood ? ' ü™µ' + ld.cost.wood : '') + '</span>';
        d.innerHTML = '<span class="sico">' + item.ico + '</span><div class="snm">' + item.name + '</div><div class="sds">' + item.desc + (ld ? '<br>‚Üí' + ld.lbl : '') + '</div>' + cs + '<div class="slv">Lv ' + lv + '/' + item.maxLv + '</div>';
        if (!maxed) d.onclick = () => buyItem(item);
        grid.appendChild(d);
      });
    }
    function openShop() { buildShopUI(); document.getElementById('shop').classList.add('open'); }
    function closeShop() { document.getElementById('shop').classList.remove('open'); }

    // ===== INPUT =====
    function handleStart(tx, ty, id) {
      if (g.nearBase && Math.hypot(tx - (W - 62), ty - (H - 185)) < 34) { openShop(); return; }
      if (Math.hypot(tx - (W - 62), ty - (H - 100)) < 40) { g.actDown = true; g.actId = id; if (g.nearBase && g.meat > 0) sellMeat(); return; }
      if (!g.joyActive && tx < W * .5 && ty > H * .42) { g.joyActive = true; g.joyId = id; g.joyOX = tx; g.joyOY = ty; g.joyDX = 0; g.joyDY = 0; }
    }
    function handleMove(tx, ty, id) {
      if (id === g.joyId) { const dx = tx - g.joyOX, dy = ty - g.joyOY, len = Math.hypot(dx, dy); if (len > 0) { const c = Math.min(len, JRAD); g.joyDX = (dx / len) * (c / JRAD); g.joyDY = (dy / len) * (c / JRAD); } else { g.joyDX = 0; g.joyDY = 0; } }
    }
    function handleEnd(id) {
      if (id === g.joyId) { g.joyActive = false; g.joyId = null; g.joyDX = 0; g.joyDY = 0; }
      if (id === g.actId) { g.actDown = false; g.actId = null; }
    }
    function onTS(e) { e.preventDefault(); for (const t of e.changedTouches) handleStart(t.clientX, t.clientY, t.identifier); }
    function onTM(e) { e.preventDefault(); for (const t of e.changedTouches) handleMove(t.clientX, t.clientY, t.identifier); }
    function onTE(e) { e.preventDefault(); for (const t of e.changedTouches) handleEnd(t.identifier); }
    cv.addEventListener('touchstart', onTS, { passive: false });
    cv.addEventListener('touchmove', onTM, { passive: false });
    cv.addEventListener('touchend', onTE, { passive: false });
    cv.addEventListener('touchcancel', onTE, { passive: false });

    let mDown = false;
    cv.addEventListener('mousedown', e => { if (e.button !== 0) return; e.preventDefault(); mDown = true; handleStart(e.clientX, e.clientY, 'm'); });
    window.addEventListener('mousemove', e => { if (mDown) handleMove(e.clientX, e.clientY, 'm'); });
    window.addEventListener('mouseup', e => { if (e.button !== 0) return; if (mDown) { mDown = false; handleEnd('m'); } });

    const keys = {};
    window.addEventListener('keydown', e => {
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
      keys[e.code] = true;
      if (e.code === 'Space' || e.code === 'Enter') { g.actDown = true; g.actId = 'k'; if (g.nearBase && g.meat > 0) sellMeat(); }
      updateJoyKey();
    });
    window.addEventListener('keyup', e => {
      if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
      keys[e.code] = false;
      if (e.code === 'Space' || e.code === 'Enter') { if (g.actId === 'k') { g.actDown = false; g.actId = null; } }
      updateJoyKey();
    });
    function updateJoyKey() {
      if (g.joyId && g.joyId !== 'k') return;
      let dx = 0, dy = 0;
      if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
      if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
      if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
      if (keys['ArrowDown'] || keys['KeyS']) dy += 1;
      if (dx || dy) {
        const len = Math.hypot(dx, dy);
        g.joyDX = dx / len; g.joyDY = dy / len;
        if (!g.joyActive) { g.joyActive = true; g.joyId = 'k'; g.joyOX = 80; g.joyOY = H - 115; }
      } else if (g.joyId === 'k') {
        g.joyActive = false; g.joyId = null; g.joyDX = 0; g.joyDY = 0;
      }
    }

    // ===== UTIL =====
    function pAtk() { return [25, 40, 60, 90][g.p.swordLv - 1]; }
    function bDmg() { return [10, 7, 5, 3][g.p.armorLv - 1]; }
    function sellMeat() { const e = g.meat * g.sellRate; g.money += e; floatTxt('üí∞ +' + e, CX, CY - .5, '#f1c40f'); toast('üí∞ „ÅäËÇâ„ÇíÂ£≤„Çä„Åæ„Åó„ÅüÔºÅ +' + e + 'ÂÜÜ'); g.meat = 0; }
    function spawnP(x, y, color, cnt, sp) { for (let i = 0; i < cnt; i++) { const a = Math.random() * Math.PI * 2, s = .5 + Math.random() * sp; g.particles.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s - 1, life: 500 + Math.random() * 300, maxLife: 800, color, size: 3 + Math.random() * 3 }); } }
    function floatTxt(txt, wx, wy, color = 'white') { const el = document.createElement('div'); el.className = 'flt'; el.textContent = txt; el.style.color = color; const s = w2s(wx, wy); el.style.left = (s.x - 20) + 'px'; el.style.top = (s.y - 30) + 'px'; document.body.appendChild(el); setTimeout(() => el.remove(), 1200); }
    let toastTm; function toast(msg) { const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show'); clearTimeout(toastTm); toastTm = setTimeout(() => el.classList.remove('show'), 3200); }
    function moveTo(e, tx, ty, spd, dt) { const dx = tx - e.x, dy = ty - e.y, d = Math.hypot(dx, dy); if (d > .05) { e.x += (dx / d) * spd * (dt / 1000); e.y += (dy / d) * spd * (dt / 1000); e.angle = Math.atan2(dy, dx); } }

    // ===== UPDATE =====
    let lastT = null;
    function update(ts) {
      if (!lastT) lastT = ts;
      const dt = Math.min(ts - lastT, 50); lastT = ts; g.time += dt;
      const p = g.p;

      // Init bears
      g.bears.forEach(b => { if (b.init) { b.maxHp = b.hp; delete b.init; } });

      // Player move
      if (g.joyDX || g.joyDY) {
        const wdx = (g.joyDX + g.joyDY) * PSPD * (dt / 1000), wdy = (-g.joyDX + g.joyDY) * PSPD * (dt / 1000);
        p.x = Math.max(.5, Math.min(MAP - .5, p.x + wdx)); p.y = Math.max(.5, Math.min(MAP - .5, p.y + wdy));
        if (wdx || wdy) p.angle = Math.atan2(wdy, wdx);
      }
      g.cx += (p.x - g.cx) * .1; g.cy += (p.y - g.cy) * .1;
      // Ââ£„ÇíÂ∏∏„Å´ÂõûËª¢ ‚Äî „ÇØ„ÉûËøë„Åè„ÅßÁàÜÈÄü
      g.swordAngle += dt * (g.nearBear ? 0.025 : 0.012);

      // Proximity
      g.nearBase = Math.hypot(p.x - CX, p.y - CY) < 3.5;
      g.nearTree = null; let minTd = TREERANGE;
      g.trees.forEach(t => { if (t.dead) return; const d = Math.hypot(p.x - t.x, p.y - t.y); if (d < minTd) { minTd = d; g.nearTree = t; } });
      g.nearBear = null; let minBd = BATKR + .5;
      g.bears.forEach(b => { if (b.dead) return; const d = Math.hypot(p.x - b.x, p.y - b.y); if (d < minBd) { minBd = d; g.nearBear = b; } });
      g.nearWall = null; let minWd = 2.0;
      g.walls.forEach(w => { if (w.dead) return; const d = Math.hypot(p.x - w.x, p.y - w.y); if (d < minWd && w.hp < w.maxHp) { minWd = d; g.nearWall = w; } });

      // Base healing
      if (g.nearBase && p.hp < p.maxHp) {
        p.hp += 15 * (dt / 1000);
        p.hp = Math.min(p.hp, p.maxHp);
      }

      // Repair Wall
      if (g.actDown && g.nearWall && !g.nearBear && !g.nearBase && !g.nearTree) {
        if (g.wood >= 1) {
          g.repairActive = true; g.repairProg += dt / 1000;
          if (g.repairProg >= 1) {
            g.repairProg = 0; g.wood -= 1;
            g.nearWall.hp = Math.min(g.nearWall.maxHp, g.nearWall.hp + 20);
            floatTxt('üõ†Ô∏è ‰øÆÁêÜ', g.nearWall.x, g.nearWall.y, '#2ecc71');
            toast('ü™µ Êú®Êùê„ÇíÊ∂àË≤ª„Åó„Å¶Â£Å„Çí‰øÆÁêÜ„Åó„Åæ„Åó„ÅüÔºÅ');
            if (g.nearWall.hp >= g.nearWall.maxHp) g.nearWall = null;
          }
        } else { g.repairActive = false; g.repairProg = 0; toast('ü™µ Êú®Êùê„ÅåË∂≥„Çä„Åæ„Åõ„ÇìÔºÅ'); }
      } else { g.repairActive = false; g.repairProg = Math.max(0, g.repairProg - dt * .001); }

      // Chop tree
      if (g.actDown && g.nearTree && !g.nearBear && !g.nearBase && !g.nearWall) {
        g.chopActive = true; g.chopProg += dt / CHOPBASE * p.axeLv;
        if (g.chopProg >= 1) {
          g.chopProg = 0; const t = g.nearTree; t.hp--; t.wobble = 350;
          if (t.hp <= 0) { const wd = Math.floor((2 + Math.random() * 2) * t.dropMult); g.wood += wd; floatTxt('ü™µ +' + wd, t.x, t.y, '#aef'); spawnP(t.x, t.y - 1, '#5d4037', 8, 1.5); t.dead = true; t.respawn = 30000; g.nearTree = null; }
        }
      } else { g.chopActive = false; g.chopProg = Math.max(0, g.chopProg - dt * .001); }

      // Auto-attack bear
      if (p.atkCD > 0) p.atkCD -= dt; if (p.atkAnim > 0) p.atkAnim -= dt;
      if (g.nearBear && p.atkCD <= 0) {
        const dmg = pAtk(); g.nearBear.hp -= dmg; g.nearBear.hurtFlash = 200;
        p.atkCD = Math.max(500, 1000 - p.swordLv * 120); p.atkAnim = 200;
        p.angle = Math.atan2(g.nearBear.y - p.y, g.nearBear.x - p.x);
        spawnP(g.nearBear.x, g.nearBear.y - .5, '#e74c3c', 5, 1.2); floatTxt('-' + dmg, g.nearBear.x, g.nearBear.y - 1, '#ff6b6b');
        if (g.nearBear.hp <= 0) { const mt = Math.floor((2 + Math.random() * 3) * g.nearBear.dropMult); g.meat += mt; floatTxt('ü•© +' + mt, g.nearBear.x, g.nearBear.y, '#f39c12'); spawnP(g.nearBear.x, g.nearBear.y, '#8B4513', 12, 2); g.nearBear.dead = true; g.nearBear.respawn = 45000; toast('üêª „ÇØ„Éû„ÇíÂÄí„Åó„ÅüÔºÅ ü•© x' + mt); }
      }

      // Bear AI
      if (p.hurtCD > 0) p.hurtCD -= dt;
      g.bears.forEach(b => {
        if (b.dead) { b.respawn -= dt; if (b.respawn <= 0) { b.x = b.spawnX; b.y = b.spawnY; b.hp = b.maxHp; b.dead = false; b.state = 'patrol'; } return; }
        if (b.hurtFlash > 0) b.hurtFlash -= dt; if (b.atkCD > 0) b.atkCD -= dt;

        let targetWall = null;
        let minWDist = 2.0; // Distance to consider wall as blocking
        if (b.state === 'chase' || b.state === 'patrol') {
          g.walls.forEach(w => {
            if (w.dead) return;
            const wd = Math.hypot(b.x - w.x, b.y - w.y);
            if (wd < minWDist) { minWDist = wd; targetWall = w; }
          });
        }

        const dp = Math.hypot(p.x - b.x, p.y - b.y);
        if (dp < BSIGHT) b.state = 'chase'; else if (dp > BSIGHT + 2.5 && b.state === 'chase') b.state = 'patrol';

        if (targetWall) {
          // Attack wall if blocking
          if (b.atkCD <= 0) {
            targetWall.hp -= Math.floor(bDmg() * b.dmgMult);
            b.atkCD = 1000;
            spawnP(targetWall.x, targetWall.y, '#e74c3c', 4, .8);
            if (targetWall.hp <= 0) { targetWall.dead = true; toast('‚ö†Ô∏è Èò≤Â£Å„ÅåÁ†¥Â£ä„Åï„Çå„ÅüÔºÅ'); }
          }
        } else if (b.state === 'chase') {
          moveTo(b, p.x, p.y, BSPD, dt);
          if (dp < BATKR && b.atkCD <= 0 && p.hurtCD <= 0) {
            const dmg = Math.floor(bDmg() * b.dmgMult); p.hp -= dmg; p.hurtCD = 800; floatTxt('-' + dmg + ' HP', p.x, p.y - .5, '#ff4444'); spawnP(p.x, p.y, '#e74c3c', 4, .8); b.atkCD = 1200;
            if (p.hp <= 0) { p.hp = Math.floor(p.maxHp * .5); p.x = CX + .5; p.y = CY + .5; g.cx = p.x; g.cy = p.y; g.meat = Math.floor(g.meat / 2); toast('üíÄ „ÇÑ„Çâ„Çå„ÅüÔºÅÊã†ÁÇπ„Å´Êàª„Çä„Åæ„Åó„ÅüÔºà„ÅäËÇâÂçäÊ∏õÔºâ'); }
          }
        } else {
          b.wanderT -= dt; if (b.wanderT <= 0) { b.angle = Math.random() * Math.PI * 2; b.wanderT = 2000 + Math.random() * 3000; }
          const nx = b.x + Math.cos(b.angle) * .6 * (dt / 1000), ny = b.y + Math.sin(b.angle) * .6 * (dt / 1000);
          if (nx > .5 && nx < MAP - .5) b.x = nx; if (ny > .5 && ny < MAP - .5) b.y = ny;
        }
      });

      g.trees.forEach(t => { if (t.dead) { t.respawn -= dt; if (t.respawn <= 0) { t.dead = false; t.hp = t.maxHp; } } if (t.wobble > 0) t.wobble -= dt; });
      g.workers.forEach(w => updateWorker(w, dt));
      g.particles.forEach(pt => { pt.x += pt.vx * (dt / 50); pt.y += pt.vy * (dt / 50); pt.vy += .05; pt.life -= dt; });
      g.particles = g.particles.filter(pt => pt.life > 0);

      updateHUD(); render(); requestAnimationFrame(update);
    }

    function updateWorker(w, dt) {
      const aT = g.trees.filter(t => !t.dead), aB = g.bears.filter(b => !b.dead && Math.hypot(b.x - CX, b.y - CY) < g.terR + 2);
      switch (w.state) {
        case 'idle': if (aB.length > 0 && Math.random() < .4) { w.target = aB[Math.floor(Math.random() * Math.min(aB.length, 3))]; w.state = 'going_bear'; } else if (aT.length > 0) { w.target = aT[Math.floor(Math.random() * Math.min(aT.length, 5))]; w.state = 'going_tree'; } break;
        case 'going_tree': if (!w.target || w.target.dead) { w.state = 'idle'; return; } moveTo(w, w.target.x, w.target.y, 2.5, dt); if (Math.hypot(w.x - w.target.x, w.y - w.target.y) < 1.5) { w.state = 'chopping'; w.chopT = 0; } break;
        case 'chopping': if (!w.target || w.target.dead) { w.state = 'idle'; return; } w.chopT += dt; if (w.chopT > 1500) { w.chopT = 0; w.target.hp--; w.target.wobble = 200; if (w.target.hp <= 0) { w.wood += 2; w.target.dead = true; w.target.respawn = 30000; w.state = 'returning'; } } break;
        case 'going_bear': if (!w.target || w.target.dead) { w.state = 'idle'; return; } moveTo(w, w.target.x, w.target.y, 2.5, dt); if (Math.hypot(w.x - w.target.x, w.y - w.target.y) < 1.8) w.state = 'fighting'; break;
        case 'fighting': if (!w.target || w.target.dead) { w.meat += 2; w.state = 'returning'; return; } if (w.atkCD > 0) w.atkCD -= dt; else { w.target.hp -= 20; w.atkCD = 1000; if (w.target.hp <= 0) { w.meat += 2; w.target.dead = true; w.target.respawn = 45000; w.state = 'returning'; } } break;
        case 'returning': moveTo(w, CX, CY, 2.5, dt); if (Math.hypot(w.x - CX, w.y - CY) < 3.5) { g.wood += w.wood; g.meat += w.meat; if (w.wood > 0) floatTxt('ü™µ +' + w.wood, CX, CY); if (w.meat > 0) floatTxt('ü•© +' + w.meat, CX, CY); w.wood = 0; w.meat = 0; w.state = 'idle'; } break;
      }
    }

    function updateHUD() {
      const p = g.p;
      document.getElementById('h-money').textContent = Math.floor(g.money);
      document.getElementById('h-meat').textContent = g.meat;
      document.getElementById('h-wood').textContent = g.wood;
      document.getElementById('day-badge').style.display = 'none';
      document.getElementById('hp-num').textContent = Math.max(0, Math.floor(p.hp));
      document.getElementById('hp-max').textContent = p.maxHp;
      document.getElementById('hp-fill').style.width = Math.max(0, p.hp / p.maxHp * 100) + '%';
      const cw = document.getElementById('chop-wrap');
      const clbl = document.getElementById('chop-lbl');
      const cbar = document.getElementById('chop-bar');

      if (g.chopActive && g.nearTree) {
        cw.style.display = 'block'; clbl.textContent = 'ü™ì ‰ºêÊé°‰∏≠...'; clbl.style.color = '#aef';
        cbar.style.width = (g.chopProg * 100) + '%'; cbar.style.background = 'linear-gradient(90deg, #27ae60, #2ecc71)';
      } else if (g.repairActive && g.nearWall) {
        cw.style.display = 'block'; clbl.textContent = 'üõ†Ô∏è ‰øÆÁêÜ‰∏≠... (Êú®Êùê-1)'; clbl.style.color = '#f1c40f';
        cbar.style.width = (g.repairProg * 100) + '%'; cbar.style.background = 'linear-gradient(90deg, #e67e22, #f39c12)';
      } else cw.style.display = 'none';

      const hint = document.getElementById('hint');
      let ht = '';
      if (g.nearBear) ht = '‚öîÔ∏è Ëá™ÂãïÊîªÊíÉ‰∏≠ÔºÅÈÄÉ„Åí„Çã„Å™„ÇâÈõ¢„Çå„Çà„ÅÜ';
      else if (g.nearBase && g.meat > 0) ht = 'üí∞ A„Éú„Çø„É≥ = „ÅäËÇâ„ÇíÂ£≤„ÇãÔºàü•©√ó' + g.meat + 'Ôºâ';
      else if (g.nearBase && g.p.hp < g.p.maxHp) ht = '‚õ∫ „ÉÜ„É≥„Éà„Åß‰ºëÊÅØ„ÉªÂõûÂæ©‰∏≠...';
      else if (g.nearBase) ht = 'üè™ „Ç∑„Éß„ÉÉ„Éó„ÅßÂº∑Âåñ„Åó„Çà„ÅÜÔºÅ';
      else if (g.nearWall) ht = 'üõ†Ô∏è A„Éú„Çø„É≥Èï∑Êäº„Åó„Åß‰øÆÁêÜÔºàÊú®Êùê„ÇíÊ∂àË≤ªÔºâ';
      else if (g.nearTree) ht = 'ü™ì A„Éú„Çø„É≥Èï∑Êäº„Åó„Åß‰ºêÊé°ÔºàËÄê‰πÖ:' + (g.nearTree ? g.nearTree.hp : 0) + 'Ôºâ';
      if (ht) { hint.textContent = ht; hint.classList.add('show'); } else hint.classList.remove('show');
    }

    // ===== RENDER =====
    const snowPts = Array.from({ length: 40 }, () => ({ x: Math.random() * 1000, y: Math.random() * 1200, sz: 1 + Math.random() * 2.5, spd: .3 + Math.random() * .5, wx: (Math.random() - .5) * .3 }));

    function render() {
      ctx.clearRect(0, 0, W, H);
      // Sky
      const sky = ctx.createLinearGradient(0, 0, 0, H); sky.addColorStop(0, '#6ab5d4'); sky.addColorStop(.5, '#9ad0e4'); sky.addColorStop(1, '#cce8f2'); ctx.fillStyle = sky; ctx.fillRect(0, 0, W, H);

      const camRX = Math.round(g.cx), camRY = Math.round(g.cy), RNG = 15;
      for (let sum = Math.max(0, (camRX - RNG) + (camRY - RNG)); sum <= (camRX + RNG) + (camRY + RNG); sum++) {
        for (let tx = camRX - RNG; tx <= camRX + RNG; tx++) {
          const ty = sum - tx; if (ty < 0 || ty >= MAP || tx < 0 || tx >= MAP) continue;
          const s = w2s(tx + .5, ty + .5); if (s.x < -TW || s.x > W + TW || s.y < -TH * 4 || s.y > H + TH) continue;
          dTile(s.x, s.y, tiles[ty][tx], tShade[ty][tx]);
        }
        if (sum === CX + CY) dBase();
        const dl = [];
        g.trees.forEach(t => { if (!t.dead && Math.round(t.x) + Math.round(t.y) === sum) dl.push({ tp: 'tree', e: t, k: t.x + t.y }); });
        g.bears.forEach(b => { if (!b.dead && Math.round(b.x) + Math.round(b.y) === sum) dl.push({ tp: 'bear', e: b, k: b.x + b.y }); });
        g.workers.forEach(w => { if (Math.round(w.x) + Math.round(w.y) === sum) dl.push({ tp: 'worker', e: w, k: w.x + w.y }); });
        g.walls.forEach(w => { if (!w.dead && Math.round(w.x) + Math.round(w.y) === sum) dl.push({ tp: 'wall', e: w, k: w.x + w.y }); });
        if (Math.round(g.p.x) + Math.round(g.p.y) === sum) dl.push({ tp: 'player', e: g.p, k: g.p.x + g.p.y });
        dl.sort((a, b) => a.k - b.k);
        dl.forEach(d => { const sp = w2s(d.e.x, d.e.y); if (d.tp === 'tree') dTree(sp.x, sp.y, d.e); else if (d.tp === 'bear') dBear(sp.x, sp.y, d.e); else if (d.tp === 'worker') dWorkerChar(sp.x, sp.y, d.e); else if (d.tp === 'player') dPlayer(sp.x, sp.y, d.e); else if (d.tp === 'wall') dWall(sp.x, sp.y, d.e); });
      }

      // Territory ring
      const tc = w2s(CX, CY), te = w2s(CX + g.terR, CY), tr = Math.abs(te.x - tc.x);
      ctx.save(); ctx.setLineDash([8, 5]); ctx.strokeStyle = 'rgba(52,152,219,.38)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.ellipse(tc.x, tc.y, tr, tr * TH / TW, 0, 0, Math.PI * 2); ctx.stroke(); ctx.setLineDash([]); ctx.restore();

      // Particles
      g.particles.forEach(pt => { const s = w2s(pt.x, pt.y); ctx.globalAlpha = pt.life / pt.maxLife; ctx.fillStyle = pt.color; ctx.beginPath(); ctx.arc(s.x, s.y, pt.size * ctx.globalAlpha, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1;

      dJoy(); dActBtn(); if (g.nearBase) dShopBtn(); dSnow();

    }

    function dTile(sx, sy, type, shade) {
      const hw = TW / 2, hh = TH / 2;
      let col;
      if (type === 3) { ctx.save(); ctx.globalAlpha = .65; col = '#3a4a56'; }
      else if (type === 2) col = 'hsl(35,' + (55 + shade * 80) + '%,' + (65 + shade * 40) + '%)';
      else if (type === 1) col = 'hsl(205,' + (40 + shade * 80) + '%,' + (74 + shade * 40) + '%)';
      else col = 'hsl(210,20%,' + (88 + shade * 50) + '%)';
      ctx.beginPath(); ctx.moveTo(sx, sy - hh); ctx.lineTo(sx + hw, sy); ctx.lineTo(sx, sy + hh); ctx.lineTo(sx - hw, sy); ctx.closePath();
      ctx.fillStyle = col; ctx.fill(); ctx.strokeStyle = 'rgba(0,0,0,.07)'; ctx.lineWidth = .5; ctx.stroke();
      if (type === 3) ctx.restore();
    }

    function dBase() {
      const s = w2s(CX, CY), sx = s.x, sy = s.y; ctx.save();
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,.16)'; ctx.beginPath(); ctx.ellipse(sx, sy + 5, 50, 14, 0, 0, Math.PI * 2); ctx.fill();
      // Back walls
      ctx.fillStyle = '#7a5c10'; ctx.beginPath(); ctx.moveTo(sx - 35, sy - 28); ctx.lineTo(sx, sy - 46); ctx.lineTo(sx, sy - 18); ctx.lineTo(sx - 35, sy); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#6b4e0c'; ctx.beginPath(); ctx.moveTo(sx, sy - 46); ctx.lineTo(sx + 35, sy - 28); ctx.lineTo(sx + 35, sy); ctx.lineTo(sx, sy - 18); ctx.closePath(); ctx.fill();
      // Roof
      ctx.fillStyle = '#b03a2e'; ctx.beginPath(); ctx.moveTo(sx - 38, sy - 26); ctx.lineTo(sx, sy - 50); ctx.lineTo(sx + 38, sy - 26); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#7b241c'; ctx.beginPath(); ctx.moveTo(sx, sy - 50); ctx.lineTo(sx + 38, sy - 26); ctx.lineTo(sx + 36, sy - 26); ctx.lineTo(sx, sy - 48); ctx.closePath(); ctx.fill();
      // Snow on roof
      ctx.fillStyle = 'rgba(220,240,255,.7)'; ctx.beginPath(); ctx.moveTo(sx - 36, sy - 26); ctx.lineTo(sx, sy - 50); ctx.lineTo(sx + 36, sy - 26); ctx.lineTo(sx + 30, sy - 24); ctx.lineTo(sx, sy - 47); ctx.lineTo(sx - 30, sy - 24); ctx.closePath(); ctx.fill();
      // Door
      ctx.fillStyle = '#4a3008'; ctx.fillRect(sx - 9, sy - 28, 16, 22); ctx.fillStyle = '#f1c40f'; ctx.fillRect(sx + 4, sy - 20, 3, 3);
      // Fence posts
      for (let i = -3; i <= 3; i++) { if (i === 0) continue; ctx.fillStyle = '#5c3d0a'; ctx.fillRect(sx + i * 11 - 3, sy - 4, 6, 10); }
      // Flag
      ctx.strokeStyle = '#95a5a6'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(sx, sy - 50); ctx.lineTo(sx, sy - 70); ctx.stroke();
      ctx.fillStyle = '#e74c3c'; ctx.beginPath(); ctx.moveTo(sx, sy - 70); ctx.lineTo(sx + 16, sy - 64); ctx.lineTo(sx, sy - 58); ctx.closePath(); ctx.fill();

      // Healing Tent (Visuals)
      ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.moveTo(sx - 45, sy + 2); ctx.lineTo(sx - 35, sy - 18); ctx.lineTo(sx - 25, sy + 2); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#34495e'; ctx.beginPath(); ctx.moveTo(sx - 35, sy - 18); ctx.lineTo(sx - 25, sy + 2); ctx.lineTo(sx - 20, sy + 2); ctx.lineTo(sx - 30, sy - 18); ctx.closePath(); ctx.fill();
      ctx.fillStyle = '#1abc9c'; ctx.fillRect(sx - 37, sy - 5, 4, 4); // Plus icon H
      ctx.fillRect(sx - 39, sy - 3, 8, 4); // Plus icon V

      // Sign
      ctx.fillStyle = 'rgba(0,0,0,.6)'; ctx.beginPath(); ctx.roundRect(sx - 18, sy - 47, 36, 12, 3); ctx.fill();
      ctx.fillStyle = '#f1c40f'; ctx.font = 'bold 9px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('BASE', sx, sy - 41);
      ctx.restore();
    }

    function dTree(sx, sy, t) {
      ctx.save();
      if (t.wobble > 0) { ctx.translate(sx, sy); ctx.rotate(Math.sin(Date.now() * .015) * .18); ctx.translate(-sx, -sy); }
      ctx.fillStyle = 'rgba(0,0,0,.14)'; ctx.beginPath(); ctx.ellipse(sx, sy, 20, 6, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 5, sy - 20, 10, 20); ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 4, sy - 20, 5, 20);
      const h = t.hp / t.maxHp > .5, g1 = h ? '#27ae60' : '#e67e22', g2 = h ? '#1e8449' : '#d35400', g3 = h ? '#2ecc71' : '#f39c12';
      ctx.fillStyle = g2; ctx.beginPath(); ctx.moveTo(sx - 22, sy - 8); ctx.lineTo(sx, sy - 28); ctx.lineTo(sx + 22, sy - 8); ctx.closePath(); ctx.fill();
      ctx.fillStyle = g1; ctx.beginPath(); ctx.moveTo(sx - 16, sy - 20); ctx.lineTo(sx, sy - 38); ctx.lineTo(sx + 16, sy - 20); ctx.closePath(); ctx.fill();
      ctx.fillStyle = g3; ctx.beginPath(); ctx.moveTo(sx - 10, sy - 32); ctx.lineTo(sx, sy - 48); ctx.lineTo(sx + 10, sy - 32); ctx.closePath(); ctx.fill();
      ctx.fillStyle = 'rgba(220,240,255,.8)'; ctx.beginPath(); ctx.moveTo(sx - 5, sy - 42); ctx.lineTo(sx, sy - 50); ctx.lineTo(sx + 5, sy - 42); ctx.closePath(); ctx.fill();
      for (let i = 0; i < t.maxHp; i++) { ctx.fillStyle = i < t.hp ? '#2ecc71' : '#7f8c8d'; ctx.beginPath(); ctx.arc(sx - 6 + i * 6, sy - 55, 3, 0, Math.PI * 2); ctx.fill(); }
      ctx.restore();
    }

    function dBear(sx, sy, b) {
      ctx.save();
      const hurt = b.hurtFlash > 0, aggro = b.state === 'chase';
      const dir = Math.cos(b.angle) >= 0 ? 1 : -1;
      ctx.fillStyle = 'rgba(0,0,0,.17)'; ctx.beginPath(); ctx.ellipse(sx, sy, 22, 7, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = hurt ? '#e74c3c' : aggro ? '#922b21' : '#795548';
      ctx.beginPath(); ctx.ellipse(sx, sy - 14, 21, 16, 0, 0, Math.PI * 2); ctx.fill();
      const hx = sx + dir * 14;
      ctx.fillStyle = hurt ? '#f1948a' : aggro ? '#a93226' : '#8d6e63';
      ctx.beginPath(); ctx.arc(hx, sy - 28, 13, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#6d4c41'; ctx.beginPath(); ctx.arc(hx - 5, sy - 39, 6, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(hx + 5, sy - 39, 6, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = aggro ? '#f1c40f' : '#212121'; ctx.beginPath(); ctx.arc(hx - 4, sy - 30, 2.5, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(hx + 4, sy - 30, 2.5, 0, Math.PI * 2); ctx.fill();
      if (aggro) { ctx.strokeStyle = '#922b21'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(hx - 7, sy - 34); ctx.lineTo(hx - 1, sy - 32); ctx.stroke(); ctx.beginPath(); ctx.moveTo(hx + 1, sy - 32); ctx.lineTo(hx + 7, sy - 34); ctx.stroke(); }
      const bw = 44, r = Math.max(0, b.hp / b.maxHp);
      ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(sx - bw / 2, sy - 48, bw, 5);
      ctx.fillStyle = r > .5 ? '#2ecc71' : r > .25 ? '#f39c12' : '#e74c3c'; ctx.fillRect(sx - bw / 2, sy - 48, bw * r, 5);
      ctx.restore();
    }

    function dPlayer(sx, sy, p) {
      ctx.save();
      if (p.hurtCD > 0 && Math.floor(Date.now() / 100) % 2 === 0) { ctx.restore(); return; }

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,.2)'; ctx.beginPath(); ctx.ellipse(sx, sy, 16, 5, 0, 0, Math.PI * 2); ctx.fill();

      // === ÁõæÔºàÂ∑¶ÂÅ¥„Å´Âõ∫ÂÆöË°®Á§∫„ÄÅarmorLv„ÅßÂ§ß„Åç„Åè„Å™„ÇãÔºâ===
      const shieldSizes = [0, 12, 17, 23, 30];
      const shieldCols = ['', '#2471a3', '#1a5276', '#717d7e', '#1c2833'];
      const shieldHLs = ['', '#5dade2', '#2980b9', '#aab7b8', '#5d6d7e'];
      const ss = shieldSizes[p.armorLv];
      if (ss > 0) {
        ctx.save(); ctx.translate(sx - 18, sy - 22);
        // Shield body (hexagonal)
        ctx.fillStyle = shieldCols[p.armorLv];
        ctx.beginPath();
        ctx.moveTo(0, -ss); ctx.lineTo(ss * 0.65, -ss * 0.4);
        ctx.lineTo(ss * 0.65, ss * 0.4); ctx.lineTo(0, ss * 0.7);
        ctx.lineTo(-ss * 0.65, ss * 0.4); ctx.lineTo(-ss * 0.65, -ss * 0.4);
        ctx.closePath(); ctx.fill();
        // Highlight
        ctx.fillStyle = shieldHLs[p.armorLv];
        ctx.beginPath();
        ctx.moveTo(0, -ss * 0.8); ctx.lineTo(ss * 0.4, -ss * 0.3);
        ctx.lineTo(ss * 0.4, ss * 0.1); ctx.lineTo(0, ss * 0.3);
        ctx.lineTo(-ss * 0.4, ss * 0.1); ctx.lineTo(-ss * 0.4, -ss * 0.3);
        ctx.closePath(); ctx.fill();
        // Rim
        ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, -ss); ctx.lineTo(ss * 0.65, -ss * 0.4);
        ctx.lineTo(ss * 0.65, ss * 0.4); ctx.lineTo(0, ss * 0.7);
        ctx.lineTo(-ss * 0.65, ss * 0.4); ctx.lineTo(-ss * 0.65, -ss * 0.4);
        ctx.closePath(); ctx.stroke();
        // Lv3+ Á¥ãÁ´†
        if (p.armorLv >= 3) {
          ctx.fillStyle = '#f1c40f';
          ctx.fillRect(-2, -ss * 0.45, 4, ss * 0.75);
          ctx.fillRect(-ss * 0.3, -ss * 0.05, ss * 0.6, 4);
        }
        ctx.restore();
      }

      // Body
      ctx.fillStyle = '#154360'; ctx.beginPath(); ctx.roundRect(sx - 12, sy - 28, 24, 28, 6); ctx.fill();
      ctx.fillStyle = '#2980b9'; ctx.beginPath(); ctx.roundRect(sx - 11, sy - 28, 13, 22, 5); ctx.fill();
      ctx.fillStyle = '#ecf0f1'; ctx.fillRect(sx - 12, sy - 12, 24, 4); ctx.fillRect(sx - 12, sy - 28, 24, 3);
      ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 12, sy - 14, 24, 4);
      ctx.fillStyle = '#f39c12'; ctx.fillRect(sx - 3, sy - 14, 6, 4);
      ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(sx, sy - 37, 11, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#d5dbdb'; ctx.beginPath(); ctx.arc(sx, sy - 31, 8, 0, Math.PI); ctx.fill();
      ctx.fillStyle = '#1c2833'; ctx.fillRect(sx - 14, sy - 51, 28, 16);
      ctx.fillStyle = '#85c1e9'; ctx.fillRect(sx - 14, sy - 51, 28, 6);
      ctx.fillStyle = 'white'; ctx.fillRect(sx - 14, sy - 39, 28, 4);
      ctx.fillStyle = '#2c3e50'; ctx.fillRect(sx - 5, sy - 41, 3, 3); ctx.fillRect(sx + 2, sy - 41, 3, 3);

      // === Ââ£ÔºàÊâã„ÅÆ‰ΩçÁΩÆ„ÇíÂõ∫ÂÆö„Éî„Éú„ÉÉ„Éà„Å´„Åó„Å¶ËÖï„Åî„Å®„Åê„Çã„Åê„ÇãÂõûËª¢Ôºâ===
      const swordLens = [18, 28, 38, 52];
      const swordWs = [3, 4, 5, 6];
      const swordCols = ['#bdc3c7', '#d5dbdb', '#82e0aa', '#fdebd0'];
      const swordGlow = [null, null, '#27ae60', '#f39c12'];
      const sl = swordLens[p.swordLv - 1];
      const sw = swordWs[p.swordLv - 1];
      // ÊåÅ„Å°Êâã„ÅØ‰Ωì„ÅÆÂè≥ËÇ©„ÅÇ„Åü„Çä„Å´Âõ∫ÂÆö
      const handX = sx + 8;
      const handY = sy - 22;
      ctx.save();
      ctx.translate(handX, handY);
      ctx.rotate(g.swordAngle);
      if (swordGlow[p.swordLv - 1]) { ctx.shadowBlur = 14; ctx.shadowColor = swordGlow[p.swordLv - 1]; }
      // „Ç∞„É™„ÉÉ„ÉóÔºà„Éî„Éú„ÉÉ„ÉàËµ∑ÁÇπÔºâ
      ctx.fillStyle = '#6d4c41'; ctx.fillRect(-sw / 2 + 1, 0, sw - 2, 10);
      // „Ç¨„Éº„Éâ
      ctx.fillStyle = '#f39c12'; ctx.fillRect(-8, 8, 16, 4);
      // „Éñ„É¨„Éº„ÉâÔºà„Ç¨„Éº„Éâ„Åã„ÇâÂÖà„Å´‰º∏„Å≥„ÇãÔºâ
      ctx.fillStyle = swordCols[p.swordLv - 1];
      ctx.fillRect(-sw / 2, 12, sw, sl);
      // ÂÖàÁ´Ø
      ctx.fillStyle = 'white';
      ctx.beginPath(); ctx.moveTo(-sw / 2, 12 + sl); ctx.lineTo(sw / 2, 12 + sl); ctx.lineTo(0, 12 + sl + 8); ctx.closePath(); ctx.fill();
      // Lv4 Èáë„ÅÆ„Ç®„ÉÉ„Ç∏
      if (p.swordLv === 4) {
        ctx.fillStyle = 'rgba(255,215,0,0.8)';
        ctx.fillRect(-sw / 2, 12, 2, sl);
        ctx.fillRect(sw / 2 - 2, 12, 2, sl);
      }
      ctx.shadowBlur = 0;
      ctx.restore();

      // === ‰ºêÊé°‰∏≠„ÅØÊñß„ÇÇÂõûËª¢ÔºàaxeLv„ÅßÈÄü„Åè„Å™„ÇãÔºâ===
      if (g.chopActive && g.nearTree) {
        const axeAngle = g.swordAngle * 1.5 + Math.PI;
        const ax = sx + Math.cos(axeAngle) * 16;
        const ay = sy - 18 + Math.sin(axeAngle) * 8;
        ctx.save(); ctx.translate(ax, ay); ctx.rotate(axeAngle + g.time * 0.006 * p.axeLv);
        if (p.axeLv >= 3) { ctx.shadowBlur = 10; ctx.shadowColor = '#27ae60'; }
        ctx.fillStyle = '#5d4037'; ctx.fillRect(-2, -18, 4, 24);
        ctx.fillStyle = '#9e9e9e'; ctx.beginPath(); ctx.moveTo(-2, -18); ctx.lineTo(14, -9); ctx.lineTo(11, -2); ctx.lineTo(-2, -2); ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#e0e0e0'; ctx.beginPath(); ctx.moveTo(-2, -18); ctx.lineTo(9, -13); ctx.lineTo(8, -7); ctx.lineTo(-2, -7); ctx.closePath(); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      ctx.restore();
    }

    function dWall(sx, sy, w) {
      ctx.save();
      // Wall base/shadow
      ctx.fillStyle = 'rgba(0,0,0,.3)'; ctx.beginPath(); ctx.ellipse(sx, sy, 30, 15, 0, 0, Math.PI * 2); ctx.fill();
      // Logs forming the wall
      ctx.fillStyle = '#4e342e'; ctx.fillRect(sx - 25, sy - 35, 10, 35); ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 23, sy - 35, 6, 35);
      ctx.fillStyle = '#3e2723'; ctx.fillRect(sx - 15, sy - 40, 10, 40); ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 13, sy - 40, 6, 40);
      ctx.fillStyle = '#4e342e'; ctx.fillRect(sx - 5, sy - 45, 10, 45); ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx - 3, sy - 45, 6, 45);
      ctx.fillStyle = '#3e2723'; ctx.fillRect(sx + 5, sy - 40, 10, 40); ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 7, sy - 40, 6, 40);
      ctx.fillStyle = '#4e342e'; ctx.fillRect(sx + 15, sy - 35, 10, 35); ctx.fillStyle = '#6d4c41'; ctx.fillRect(sx + 17, sy - 35, 6, 35);
      // Horizontal beam
      ctx.fillStyle = '#3e2723'; ctx.fillRect(sx - 28, sy - 20, 56, 6);
      ctx.fillStyle = '#5d4037'; ctx.fillRect(sx - 28, sy - 18, 56, 2);

      // Health bar
      if (w.hp < w.maxHp) {
        const r = Math.max(0, w.hp / w.maxHp);
        ctx.fillStyle = 'rgba(0,0,0,.5)'; ctx.fillRect(sx - 15, sy - 55, 30, 4);
        ctx.fillStyle = r > .5 ? '#2ecc71' : r > .25 ? '#f39c12' : '#e74c3c'; ctx.fillRect(sx - 15, sy - 55, 30 * r, 4);
      }
      ctx.restore();
    }

    function dWorkerChar(sx, sy, w) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.16)'; ctx.beginPath(); ctx.ellipse(sx, sy, 12, 4, 0, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.roundRect(sx - 9, sy - 20, 18, 20, 4); ctx.fill();
      ctx.fillStyle = '#f5cba7'; ctx.beginPath(); ctx.arc(sx, sy - 27, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#2c3e50'; ctx.fillRect(sx - 10, sy - 34, 20, 9);
      if (w.state === 'chopping' || w.state === 'going_tree') { ctx.fillStyle = '#5d4037'; ctx.fillRect(sx + 8, sy - 26, 3, 20); ctx.fillStyle = '#9e9e9e'; ctx.fillRect(sx + 8, sy - 26, 12, 8); }
      else { ctx.fillStyle = '#607d8b'; ctx.fillRect(sx + 8, sy - 26, 3, 18); ctx.fillStyle = '#90a4ae'; ctx.fillRect(sx + 8, sy - 26, 8, 6); }
      ctx.restore();
    }

    function dJoy() {
      const bx = g.joyOX, by = g.joyOY;
      ctx.save(); ctx.globalAlpha = g.joyActive ? .72 : .32;
      ctx.strokeStyle = 'rgba(255,255,255,.8)'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.arc(bx, by, JRAD, 0, Math.PI * 2); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.07)'; ctx.beginPath(); ctx.arc(bx, by, JRAD, 0, Math.PI * 2); ctx.fill();
      const kx = bx + g.joyDX * JRAD, ky = by + g.joyDY * JRAD;
      ctx.fillStyle = 'rgba(0,0,0,.22)'; ctx.beginPath(); ctx.arc(kx + 2, ky + 3, 26, 0, Math.PI * 2); ctx.fill();
      const gr = ctx.createRadialGradient(kx - 6, ky - 6, 3, kx, ky, 26); gr.addColorStop(0, 'rgba(255,255,255,.92)'); gr.addColorStop(1, 'rgba(160,195,220,.75)');
      ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(kx, ky, 26, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = 'rgba(100,150,200,.5)'; ctx.lineWidth = 1.5; ctx.stroke();
      ctx.restore();
    }

    function dActBtn() {
      const bx = W - 62, by = H - 100;
      let icon = '‚ùÑÔ∏è', cl = ['#2980b9', '#1a5276'];
      if (g.nearBear) { icon = '‚öîÔ∏è'; cl = ['#e74c3c', '#922b21']; }
      else if (g.nearWall) { icon = 'üõ†Ô∏è'; cl = ['#e67e22', '#d35400']; }
      else if (g.nearTree) { icon = 'ü™ì'; cl = ['#27ae60', '#1e8449']; }
      else if (g.nearBase && g.meat > 0) { icon = 'üí∞'; cl = ['#f39c12', '#d35400']; }
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.26)'; ctx.beginPath(); ctx.arc(bx + 3, by + 3, 36, 0, Math.PI * 2); ctx.fill();
      const gr = ctx.createRadialGradient(bx - 8, by - 8, 3, bx, by, 36); gr.addColorStop(0, cl[0]); gr.addColorStop(1, cl[1]);
      ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(bx, by, 36, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.lineWidth = 2.5; ctx.stroke();
      if (g.actDown) { ctx.globalAlpha = .28; ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(bx, by, 36, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; }
      ctx.font = '27px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(icon, bx, by);
      ctx.font = 'bold 8px Arial'; ctx.fillStyle = 'rgba(255,255,255,.7)'; ctx.fillText('A', bx, by + 29);
      ctx.restore();
    }

    function dShopBtn() {
      const bx = W - 62, by = H - 187; ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.24)'; ctx.beginPath(); ctx.arc(bx + 2, by + 2, 30, 0, Math.PI * 2); ctx.fill();
      const gr = ctx.createRadialGradient(bx - 6, by - 6, 2, bx, by, 30); gr.addColorStop(0, '#f39c12'); gr.addColorStop(1, '#d35400');
      ctx.fillStyle = gr; ctx.beginPath(); ctx.arc(bx, by, 30, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.35)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.font = '22px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('üè™', bx, by);
      ctx.font = 'bold 8px Arial'; ctx.fillStyle = 'white'; ctx.fillText('SHOP', bx, by + 23); ctx.restore();
    }

    function dSnow() {
      ctx.save(); ctx.fillStyle = 'rgba(255,255,255,.55)';
      snowPts.forEach(s => { s.y += s.spd; s.x += s.wx; if (s.y > H) { s.y = -5; s.x = Math.random() * W; } if (s.x > W) s.x = 0; if (s.x < 0) s.x = W; ctx.beginPath(); ctx.arc(s.x, s.y, s.sz, 0, Math.PI * 2); ctx.fill(); });
      ctx.restore();
    }

    // ===== ACCESS LOG =====
    (function () {
      try {
        const url = "https://script.google.com/macros/s/AKfycbznxYkj5ixnK_pHkGR8LUYhEYdvSYpaiF3x4LaZy964wlu068oak1X1uuIiyqCEtGWF/exec?page=whiteout"
          + "&ref=" + encodeURIComponent(document.referrer)
          + "&ua=" + encodeURIComponent(navigator.userAgent)
          + "&lang=" + encodeURIComponent(navigator.language)
          + "&w=" + screen.width + "&h=" + screen.height;
        fetch(url, { method: "GET", mode: "no-cors" }).catch(() => { });
      } catch (e) { }
    })();

    // ===== INIT =====
    genMap(); spawnEntities();
    g.joyOX = 80; g.joyOY = H - 115;
    requestAnimationFrame(update);
    toast('‚ùÑÔ∏è „Ç∏„Éß„Ç§„Çπ„ÉÜ„Ç£„ÉÉ„ÇØ„ÅßÁßªÂãïÔºÅ„ÇØ„Éû„ÇíÂÄí„Åó„Å¶ü•©„ÇíÂèñ„Çä„ÄÅÊã†ÁÇπ„ÅßA„Éú„Çø„É≥„ÅßÂ£≤„Çç„ÅÜÔºÅ');
  </script>
</body>

</html>